{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}
 
let NONE = "none"
func getNumberByKey(key: String) = {
    let num = match getInteger(this, key) {
            case a:Int => a
            case _ => 0
    }
    num
}
func getStrByKey(key: String) = {
    let str = match getString(this, key) {
            case a:String => a
            case _ => NONE
    }
    str
}

func getKeyWhitelistRef(account: String) = "wl_ref_" + account
func getKeyWhitelistStatus(account: String) = "wl_sts_" + account
func getKeyBalance(account: String) = "balance_" + account
func getKeyWhitelistBio(account: String) = "wl_bio_" + account
func getKeyWhitelistBlock(account: String) = "wl_blk_" + account
func getKeyItemAuthor(item: String) = "author_" + item
func getKeyItemBlock(item: String) = "block_" + item
func getKeyItemVotingExpiration(item: String) = "expiration_block_" + item
func getKeyItemBank(item: String) = "bank_" + item
func getKeyItemStatus(item: String) = "status_" + item
func getKeyItemData(item: String) = "datajson_" + item
func getKeyFreeItemAuthor(item: String) = "free_author_" + item
func getKeyFreeItemBlock(item: String) = "free_block_" + item
func getKeyFreeItemStatus(item: String) = "free_status_" + item
func getKeyFreeItemData(item: String) = "free_datajson_" + item
func getKeyFreeItemContest(item: String) = "free_contest_" + item
func getKeyContestData(item: String) = "contest_datajson_" + item
func getKeyContestType(item: String) = "contest_type_" + item
func getKeyItemCrowdExpiration(item: String) = "expiration_one_" + item
func getKeyItemWhaleExpiration(item: String) = "expiration_two_" + item
func getKeyItemNCommits(item: String) = "ncommits_" + item
func getKeyItemAccReportData(item: String, account: String) = "report_" + item + "_" + account
func getKeyItemAccCommit(item: String, account: String) = "commit_" + item + "_" + account
func getKeyItemAccReveal(item: String, account: String) = "reveal_" + item + "_" + account
func getKeyItemVotesYes(item: String) = "cnt_yes_" + item
func getKeyItemVotesNo(item: String) = "cnt_no_" + item
func getKeyItemAccFinal(item: String, account: String) = "final_" + item + "_" + account
func getKeyItemFundPositive(item: String) = "positive_fund_" + item
func getKeyItemFundNegative(item: String) = "negative_fund_" + item
func getKeyItemAccFundPositive(item: String, account: String) = getKeyItemFundPositive(item) + "_" + account
func getKeyItemAccFundNegative(item: String, account: String) = getKeyItemFundNegative(item) + "_" + account
func getKeyItemAccReviewsCnt(item: String, account: String) = "reviews_cnt_" + item + "_" + account
func getKeyItemAccReview(item: String, account: String) = "review_" + item + "_" + account
func getKeyItemAccReviewText(item: String, account: String, cnt: String) = getKeyItemAccReview(item, account) + "_text_id:" + cnt
func getKeyItemAccReviewMode(item: String, account: String, cnt: String) = getKeyItemAccReview(item, account) + "_mode_id:" + cnt
func getKeyItemAccReviewTier(item: String, account: String, cnt: String) = getKeyItemAccReview(item, account) + "_tier_id:" + cnt
func getKeyItemAccVoteReviewText(item: String, account: String) = getKeyItemAccReview(item, account) + "_votereview"
func getKeyItemAccWhaleReviewText(item: String, account: String) = getKeyItemAccReview(item, account) + "_whalereview"
func getKeyItemBuyoutAmount(item: String) = "buyout_amount_" + item
func getKeyItemAccWinnings(item: String, account: String) = "winnings_" + item + "_" + account
 
func getValueWhitelistRef(account: String) = getStrByKey(getKeyWhitelistRef(account))
func getValueWhitelistStatus(account: String) = getStrByKey(getKeyWhitelistStatus(account))
func getValueBalance(account: String) = getNumberByKey(getKeyBalance(account))
func getValueWhitelistBio(account: String) = getStrByKey(getKeyWhitelistBio(account))
func getValueWhitelistBlock(account: String) = getStrByKey(getKeyWhitelistBlock(account))
func getValueItemAuthor(item: String) = getStrByKey(getKeyItemAuthor(item))
func getValueItemBlock(item: String) = getNumberByKey(getKeyItemBlock(item))
func getValueItemVotingExpiration(item: String) = getNumberByKey(getKeyItemVotingExpiration(item))
func getValueItemBank(item: String) = getNumberByKey(getKeyItemBank(item))
func getValueItemStatus(item: String) = getStrByKey(getKeyItemStatus(item))
func getValueItemData(item: String) = getStrByKey(getKeyItemData(item))
func getValueFreeItemAuthor(item: String) = getStrByKey(getKeyFreeItemAuthor(item))
func getValueFreeItemBlock(item: String) = getNumberByKey(getKeyFreeItemBlock(item))
func getValueFreeItemStatus(item: String) = getStrByKey(getKeyFreeItemStatus(item))
func getValueFreeItemData(item: String) = getStrByKey(getKeyFreeItemData(item))
func getValueFreeItemContest(item: String) = getStrByKey(getKeyFreeItemContest(item))
func getValueItemCrowdExpiration(item: String) = getNumberByKey(getKeyItemCrowdExpiration(item))
func getValueItemWhaleExpiration(item: String) = getNumberByKey(getKeyItemWhaleExpiration(item))
func getValueItemNCommits(item: String) = getNumberByKey(getKeyItemNCommits(item))
func getValueItemAccCommit(item: String, account: String) = getStrByKey(getKeyItemAccCommit(item, account))
func getValueItemAccReveal(item: String, account: String) = getStrByKey(getKeyItemAccReveal(item, account))
func getValueItemVotesYes(item: String) = getNumberByKey(getKeyItemVotesYes(item))
func getValueItemVotesNo(item: String) = getNumberByKey(getKeyItemVotesNo(item))
func getValueItemAccFinal(item: String, account: String) = getStrByKey(getKeyItemAccFinal(item, account))
func getValueItemFundPositive(item: String) = getNumberByKey(getKeyItemFundPositive(item))
func getValueItemFundNegative(item: String) = getNumberByKey(getKeyItemFundNegative(item))
func getValueItemAccFundPositive(item: String, account: String) = getNumberByKey(getKeyItemAccFundPositive(item, account))
func getValueItemAccFundNegative(item: String, account: String) = getNumberByKey(getKeyItemAccFundNegative(item, account))
func getValueItemAccReviewsCnt(item: String, account: String) = getNumberByKey(getKeyItemAccReviewsCnt(item, account))
func getValueItemAccReviewText(item: String, account: String, cnt: String) = getStrByKey(getKeyItemAccReviewText(item, account, cnt))
func getValueItemAccReviewMode(item: String, account: String, cnt: String) = getStrByKey(getKeyItemAccReviewMode(item, account, cnt))
func getValueItemAccReviewTier(item: String, account: String, cnt: String) = getNumberByKey(getKeyItemAccReviewTier(item, account, cnt))
func getValueItemBuyoutAmount(item: String) = getNumberByKey(getKeyItemBuyoutAmount(item))
func getValueItemAccWinnings(item: String, account: String) = getNumberByKey(getKeyItemAccWinnings(item, account))
func getContestType(item: String) = getStrByKey(getKeyContestType(item))

let NEW = "new"
let DONATED = "donated"
let REJECTED = "rejected"

let OWNERDONATE = "owner_donate"
let USERSDONATE = "users_donate"

let WHITELISTED = "registered"
let INVITED = "invited"
let WHALE = "whale"
let SPENDINVITE = "spend_invite"

let COMMIT = "voting_commit"
let REVEAL = "voting_reveal"
let FEATURED = "featured"
let DELISTED = "delisted"
let CASHOUT = "cashout"
let BUYOUT = "buyout"
let FINISHED = "finished"
let CLAIMED = "claimed"
 
let POSITIVE = "positive"
let NEGATIVE = "negative"
 
let GENESIS = "3P8Fvy1yDwNHvVrabe4ek5b9dAwxFjDKV7R"
let ADMIN = "3P9NDxt9Y6ePfM9hkQysgSvbHJvihr56Z18"

# (GLOBALS) TCR implementation with commit-reveal scheme
let VOTERS = 3
let QUORUM = 2
let TIERS = [3*100000000, 10*100000000, 100*100000000, 300*100000000, 1000*100000000]
let LISTINGFEE = 1*100000000
let VOTEBET = 1*100000000
 
let MULTIPLIER = 150
let SplitDataSymbol = "+"

@Callable(i)
func inviteuser(newaccount: String, data: String) = {
    let account = toBase58String(i.caller.bytes)
    let newstatus = getValueWhitelistStatus(newaccount)
    let currstatus = getValueWhitelistStatus(account)
    if (newstatus == WHITELISTED || newstatus == WHALE)
        then throw("User has already been registered")
    else if (currstatus != WHITELISTED && account != GENESIS && currstatus != WHALE)
        then throw("Your account should be whitelisted. status: " + currstatus)
    else {
        WriteSet([
            DataEntry(getKeyWhitelistRef(newaccount), account),
            DataEntry(getKeyWhitelistBio(newaccount), data),
            DataEntry(getKeyWhitelistStatus(newaccount), INVITED)
        ])
    }
}

@Callable(i)
func signupbylink(hash: String, data: String, type: String) = {
    let account = toBase58String(i.caller.bytes)
    let status = getValueWhitelistStatus(hash)
    if (status != INVITED)
        then throw("Referral invite needed. Current status: " + status + ", key:" + getKeyWhitelistStatus(hash) + ", account:" + hash)
    else {
        WriteSet([
            DataEntry(getKeyWhitelistBio(account), data),
            DataEntry(getKeyWhitelistBlock(account), height),
            DataEntry(getKeyWhitelistStatus(account), if (type == WHALE) then WHALE else WHITELISTED),
            DataEntry(getKeyWhitelistStatus(hash), SPENDINVITE),
            DataEntry(getKeyWhitelistRef(account), getValueWhitelistRef(hash))
        ])
    }
}

@Callable(i)
func signup(data: String, type: String) = {
    let account = toBase58String(i.caller.bytes)
    let status = getValueWhitelistStatus(account)
    if (status == NONE)
        then throw("Referral invite needed. Current status: " + status + ", key:" + getKeyWhitelistStatus(account) + ", account:" + account)
    else {
        WriteSet([
            DataEntry(getKeyWhitelistBio(account), data),
            DataEntry(getKeyWhitelistBlock(account), height),
            DataEntry(getKeyWhitelistStatus(account), if (type == WHALE) then WHALE else WHITELISTED)
        ])
    }
}

@Callable(i)
func userupdate(data: String, type: String) = {
    let account = toBase58String(i.caller.bytes)
    WriteSet([
        DataEntry(getKeyWhitelistBio(account), data),
        DataEntry(getKeyWhitelistStatus(account), if (type == WHALE) then WHALE else WHITELISTED)
    ])
}

@Callable(i)
func projupdate(item: String, data: String) = {
    let account = toBase58String(i.caller.bytes)
    if (getValueItemAuthor(item) != account) then throw("You're not author")
    else {
        WriteSet([DataEntry(getKeyItemData(item), data)])
    }
}
 
@Callable(i)
func contestAddOrUpdate(item: String, data: String, type: String) = {
    let account = toBase58String(i.caller.bytes)
    let typeContest = if(type == OWNERDONATE) then OWNERDONATE else USERSDONATE
    if ( account != ADMIN ) then throw("You're not admin")
    else {
        WriteSet([
            DataEntry(getKeyContestData(item), data),
            DataEntry(getKeyContestType(item), typeContest)
        ])
    }
}
 
@Callable(i)
func withdraw(address : String) = {
    let amount = getValueBalance(address)
    if (amount <= 0) then throw("Not enough balance")
    else ScriptResult(
        WriteSet([ DataEntry(getKeyBalance(address), 0)]),
        TransferSet([ScriptTransfer(addressFromStringValue(address), amount, unit)])
    )
}

@Callable(i)
func addFreeItem(item: String, data: String, contestId: String) = {
    let type = getContestType(contestId)
    if(type == USERSDONATE)
        then throw("Contest type is " + USERSDONATE)
    else if (getValueItemAuthor(item) != NONE)
        then throw("Item already exist")
    else 
        WriteSet([
            DataEntry(getKeyFreeItemAuthor(item), toString(i.caller)),
            DataEntry(getKeyFreeItemBlock(item), height),
            DataEntry(getKeyFreeItemStatus(item), NEW),
            DataEntry(getKeyFreeItemData(item), data),
            DataEntry(getKeyFreeItemContest(item), contestId)
        ])
}

@Callable(i)
func updateFreeItem(item: String, data: String) = {
    let status = getValueFreeItemStatus(item)
    
    if(status != NEW)
        then throw("Status is not " + NEW)
    else 
        WriteSet([
            DataEntry(getKeyFreeItemData(item), data)
        ])
}

@Callable(i)
func rejectFreeItem(item: String) = {
    let status = getValueFreeItemStatus(item)
    let contestOwner = toString(i.caller)
    if (contestOwner != ADMIN) 
        then throw("You're not admin")
    else if(status != NEW)
        then throw("Status is not " + NEW)
    else 
        WriteSet([
            DataEntry(getKeyFreeItemStatus(item), REJECTED)
        ])
}

@Callable(i)
func donateFreeItem(item: String) = {
    let status = getValueFreeItemStatus(item)
    let author = getValueFreeItemAuthor(item)
    let pmt = extract(i.payment)
    let contestOwner = toString(i.caller)
    
    if (contestOwner != ADMIN) 
        then throw("You're not admin")
    else if (isDefined(pmt.assetId)) 
        then throw("can use waves only at the moment")
    else if (pmt.amount == 0)
        then throw("invalid amount")
    else if(status != NEW)
        then throw("Status is not " + NEW)
    else 
        WriteSet([
            DataEntry(getKeyFreeItemStatus(item), DONATED),
            DataEntry(getKeyBalance(author), getValueBalance(author) + pmt.amount)
        ])
}

@Callable(i)
func additem(item: String, expVoting: Int, expCrowd: Int, expWhale: Int, data: String) = {
    let account = toBase58String(i.caller.bytes)
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) then throw("can use waves only at the moment")
    else {
        if (pmt.amount != LISTINGFEE)
            then throw("Please pay exact amount for the listing: " + toString(LISTINGFEE) + ", actual payment is: " + toString(pmt.amount))
        else if (!(expVoting > 2 && expCrowd > expVoting && expWhale > expCrowd))
            then throw("Incorrect time parameters")
        else if (getValueItemAuthor(item) != NONE)
            then throw("Item already exist")
        else WriteSet([
            DataEntry(getKeyItemAuthor(item), account),
            DataEntry(getKeyItemBlock(item), height),
            DataEntry(getKeyItemVotingExpiration(item), height + expVoting),
            DataEntry(getKeyItemBank(item), LISTINGFEE),
            DataEntry(getKeyItemStatus(item), FEATURED),
            DataEntry(getKeyItemData(item), data),
            DataEntry(getKeyItemCrowdExpiration(item), height + expCrowd),
            DataEntry(getKeyItemWhaleExpiration(item), height + expWhale)
        ])
    }
}

@Callable(i)
func reportProject(item: String, data: String) = {
    let account = toBase58String(i.caller.bytes)
    WriteSet([
        DataEntry(getKeyItemAccReportData(item, account), data)
    ])
}

@Callable(i)
func donate( item: String, tier: Int, mode: String, review: String ) = {
    let account = toBase58String(i.caller.bytes)
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) then throw("can use waves only at the moment")
    else {
        let cnt = getValueItemAccReviewsCnt(item, account) + 1
        let newnegativefund = getValueItemFundNegative(item) +
                    ( if ( mode == NEGATIVE ) then 1 else 0) * pmt.amount
        let newpositivefund = getValueItemFundPositive(item) +
                    ( if ( mode == POSITIVE ) then 1 else 0) * pmt.amount
        if (getValueItemStatus(item) != FEATURED)
            then throw("The project hasn't accepted by community")
        else if (height >= getValueItemCrowdExpiration(item))
            then throw("The time for crowdfunding has expired")
        else if (newnegativefund >= newpositivefund)
            then throw("Negative fund can't be higher than positive fund")
        else if (mode != POSITIVE && mode != NEGATIVE)
            then throw("Wrong mode parameter")
        else if (getValueItemAuthor(item) == account)
            then throw("Can't donate own project")
        else if (pmt.amount != TIERS[tier - 1])
            then throw("The payment must be equal to tier amount: " + toString(TIERS[tier - 1]))
        else WriteSet([
            DataEntry(getKeyItemAccReviewsCnt(item, account), cnt),
            DataEntry(getKeyItemAccFundPositive(item, account),
                getValueItemAccFundPositive(item, account) +
                    ( if ( mode == POSITIVE ) then 1 else 0) * pmt.amount ),
            DataEntry(getKeyItemAccFundNegative(item, account),
                getValueItemAccFundNegative(item, account) +
                    ( if ( mode == NEGATIVE ) then 1 else 0) * pmt.amount ),
            DataEntry(getKeyItemFundPositive(item), newpositivefund),
            DataEntry(getKeyItemFundNegative(item), newnegativefund),
            DataEntry(getKeyItemAccReviewText(item, account, toString(cnt)), review),
            DataEntry(getKeyItemAccReviewMode(item, account, toString(cnt)), mode),
            DataEntry(getKeyItemAccReviewTier(item, account, toString(cnt)), tier)
        ])
    }
}
 
@Callable(i)
func whale( item: String, review: String ) = {
    let account = toBase58String(i.caller.bytes)
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId)) then throw("can use waves only at the moment")
    else {
        if (getValueItemStatus(item) != FEATURED)
            then throw("The project hasn't accepted by community")
        else if (height < getValueItemCrowdExpiration(item))
            then throw("The time for crowdfunding has not expired yet")
        else if (height > getValueItemWhaleExpiration(item))
            then throw("The time for grant has expired")
        else if (getValueItemStatus(item) == BUYOUT)
            then throw("Investement has already done")
        else if (pmt.amount < (getValueItemFundPositive(item)*MULTIPLIER)/100)
            then throw("Investement must be more than "
            + toString(MULTIPLIER) + "% of supportes funds")
        else {
                let bayoutAmount = (getValueItemFundPositive(item)*MULTIPLIER)/100
                let donateAmount =  pmt.amount - bayoutAmount
                WriteSet([
                    DataEntry(getKeyItemStatus(item), BUYOUT),
                    DataEntry(getKeyItemAccWhaleReviewText(item, account), review),
                    DataEntry(getKeyBalance(getValueItemAuthor(item)),
                        getValueBalance(getValueItemAuthor(item)) + getValueItemFundPositive(item) + donateAmount),
                    DataEntry(getKeyItemBuyoutAmount(item), bayoutAmount)
            ])
        }
    }
}
 
@Callable(i)
func claimwinnings( item: String, account: String ) = {
    let status = getValueItemStatus(item)
    let isbayout = if (status == BUYOUT) then 1 else 0
    let iscrowdf = if (status != BUYOUT) then 1 else 0
    let positivefund = getValueItemFundPositive(item)
    let negativefund = getValueItemFundNegative(item)
    let share = isbayout*(getValueItemAccFundPositive(item, account)*100)/
            (if (positivefund <= 0) then 1 else positivefund) +
        iscrowdf*(getValueItemAccFundNegative(item, account)*100)/
            (if (negativefund <= 0) then 1 else negativefund)
    let tmpnegwin = (negativefund*MULTIPLIER)/100
    let betprofit = isbayout*((share*negativefund)/100) +
        iscrowdf*((share*(if (tmpnegwin < positivefund) then tmpnegwin else positivefund))/100)
    let roiprofit = isbayout*((share*getValueItemBuyoutAmount(item))/100)
    let authorprofit = (if (getValueItemAuthor(item) == account) then 1 else 0)*
        positivefund*(if (status != BUYOUT) then 1 else 0)
    if (status == DELISTED)
        then throw("The project hasn't accepted by community")
    else if (status == CASHOUT)
        then throw("Status is cashout")
    else if (getValueItemAccFinal(item, account) == CLAIMED)
        then throw("Status is claimed")
    else if (share == 0 && authorprofit == 0)
        then throw("The share equals zero")
    else if (status != BUYOUT && height <= getValueItemWhaleExpiration(item))
        then throw("The time for grant has not expired yet")
    else if (positivefund + negativefund <= 0)
        then throw("The campaign wasn't active")
    else WriteSet([
        DataEntry(getKeyBalance(account), getValueBalance(account) +
            betprofit + roiprofit + authorprofit),
        DataEntry(getKeyItemStatus(item), if (authorprofit > 0) then CASHOUT else status),
        DataEntry(getKeyItemAccFinal(item, account), CLAIMED)
    ])
}

@Callable(i)
func transfer(account: String) = {
    let pmt = extract(i.payment)
    if (isDefined(pmt.assetId))
        then throw("can use waves only at the moment")
    else TransferSet([ScriptTransfer(addressFromStringValue(account), pmt.amount, unit)])
}